# 树形数据结构的表形管理

这篇东西仍然比较无聊，它描述了如何用表对一种树形数据结构进行表达。

树形数据结构支持深度和广度遍历，优点是使用灵活，缺点是内容偶合度过高，导致难以单独存储；

而表形数据结构则更贴近数据库，优点是条目清晰，易于存储。

本文尝试在牺牲一定存储空间的条件下，用数据库的形式对树结构进行一定程度的表达。

---
- [树形数据结构的表形管理](#树形数据结构的表形管理)
  - [数据描述](#数据描述)
  - [数据可视化](#数据可视化)
  - [表的表示方式](#表的表示方式)


## 数据描述

本文采用的数据是从想不起来哪个网站上爬下来的中国地理数据，包含很完备的从省、市到区、县的地理轮廓数据。当时如果利用这些轮廓是后面的事情，这里我们关注数据的 id 字段，它代表该行政区的唯一编号，且具有“继承性”，也就是说 id 字段的包含关系代表了行政区的从属关系，举个例子，63 开头的青海省治下的全部市、区、县都会以 63 开头。

![global](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled.png)

global

![example-63](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%201.png)

example-63

从这个规律出发，我们就可以建立一棵树，一棵中国行政区划的树。根节点是中国，全部子行政区以迭代的形式存储在 children 字段中，我想这个不需要太多解释。

![Tree](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%202.png)

Tree

## 数据可视化

那么这棵树具有良好的性质，可以描述行政区之间的对应关系。有很多动态工具可以用来对它做可视化，具体可见我的前端笔记本
[Sunburst graph of China provinces](https://observablehq.com/@listenzcc/sunburst-graph-of-china-provinces "Sunburst graph of China provinces")

![Untitled](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%203.png)

![Untitled](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%204.png)

![Untitled](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%205.png)

![Untitled](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%206.png)

## 表的表示方式

可见，树的优点是非常多的，但它的缺点是数据偶合程度过高，导致无法有效存储和检索。因此我尝试将树结构以字段的方式记录在数据表中

- children，代表某个行政区的紧邻下级；
- parents，代表从根节点开始，经过哪些行政区可以达到该节点；
- sisters，代表该节点的兄弟、姐妹节点。

这样，在之后的工作中，检索速度会得到提高，提高到实时水平。这样做的代价是表的存储空间会变大。当然，这个问题可以解决，只要把表的以上三个字段与主表分开存储，按需调用就可以了。

![T](%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E5%BD%A2%E7%AE%A1%E7%90%86%208d911cebf54a4ce88cc1c13323797dd3/Untitled%207.png)

T

总之，我觉得这是个好方法，（当然，是在表的规模不会变得过大的情况下）。