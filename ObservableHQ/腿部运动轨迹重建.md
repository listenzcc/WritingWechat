## 腿部运动轨迹重建

这一个基于`THREE`的可视化工程尝试。
基于`IMU`角度信号对行走过程中的腿部运动轨迹进行重建。

---

-   [腿部运动轨迹重建](#腿部运动轨迹重建)
-   [运动信号](#运动信号)
-   [显示平台](#显示平台)
    -   [三维场景](#三维场景)
    -   [腿部树形结构](#腿部树形结构)
    -   [转动轴设定的实现方式](#转动轴设定的实现方式)

## 运动信号

`IMU`是一种记录加速度和角加速度信息的惯性导航单元。
将它固定的运动物体上，
就能够还原物体的运动过程。
在此，将`3`个`IMU`分别绑在大腿、小腿和脚上。
下面将采用一种纯粹工程化的方式对运动轨迹进行重建。

【这是一段棒到不行的视频】

## 显示平台

本文使用基于`THREE`的三维场景可视化方法，
具体包括“三维场景”和“腿部树形结构”搭建两个方面，
呈现效果如下

![Walking Leg](WalkingLeg.png)

### 三维场景

三维场景是抽象概念，
具体到实现上，
可以简单地声明一个这样的场景，
全部计算和可视化都在这个三维场景中展开。

首先，为了在工程上对场景进行展示，
就需要一个虚拟的观察者

-   camera：它有自己的位置，方向和视野；

之后，为了能够让观察者服从用户的操作，
需要为它添加控制器

-   controller：它允许用户通过鼠标的移动和滚轮，实时控制观察者的位置和视野；

接下来是可视化的客体，
需要在场景中加入需要可视化的物体三维模型，
这些模型被观察者所观察

-   geometry：它是物体的三维模型，以顶点和表面集合的形式进行维护；

为了满足实时控制和渲染的需求，
`THREE`使用异步帧调用的方法进行动画式的绘制

-   animation：它是一种异步递归调用的帧渲染方式

    ```javascript
    // Animation function will repeat it self
    function animate() {
        // ---------------------------
        // Do something amazing
        // ---------------------------

        // Call the animation AGAIN if the next frame is ready to go
        requestAnimationFrame(animate);
        // Render the scene
        renderer.render(scene, camera);
        // Update the stats
        stats.update();
    }

    // Trigger the animation
    animate();
    ```

牵扯到异步，
就会不可避免地涉及性能问题，
即系统需要根据实际运行情况来确定何时才能渲染下一帧，
需要使用状态监测模块来实时反馈当前的帧速率等信息

-   stats：它对运行状态进行实时监控并展示在三维场景渲染窗口中的恰当位置；

最后，全部成分都可以拥有适合自己的辅助线系统

-   helper：通过在场景中绘制辅助线的方式，直观的表明它是什么以及如何在场景中发挥作用。

![Walking Leg Helper](WalkingLegHelper.png)

有了以上的功能模块，
三维场景的可视化功能就宣告完成。
下面需要构建呈现腿部动作所需的三段式铰链结构。

### 腿部树形结构

腿部是一个三段式的铰链结构，
大腿连小腿，小腿连脚。
抽象来看，这是一个递归的三级随动系统，
大腿的运动同时包括小腿和脚的运动，小腿的运动又同时包括脚的运动。

本文使用三级的树形结构来描述这位的随动系统，

-   根节点从大腿出发；
-   第一级节点延伸到小腿；
-   第二级节点从小腿延伸到脚。

实现方式如图框所示

![Walking Leg Frame](WalkingLegFrame.png)

通过将运动从根节点开始在树上递归，
来实现腿部运动的三级随动。

### 转动轴设定的实现方式

最后的问题是让三维物体转动起来，
这本来不是什么大的问题，
但其难点在于`THREE`的转动机制。
`THREE`只允许物体绕它的固定轴进行旋转，
这个轴通常是在物体中心。

而受到`IMU`绑定位置的影响，
本文需要物体沿特定轴，即`IMU`位置，进行转动。
采用的方法是对物体进行“包装”

-   group：它是抽象的包装件，用于联合多个物体并转换物体的转动轴等等功能。

这个包装件相当有趣。
从抽象的角度来看，`group`是场景的同位复制，
其特点是具有自己的转动和平移参数。
而由于场景是无限大小的，
是一个无穷大小的“可数集”，
因此无论它如何转动和平移，
其中的点始终与场景中的点具有一一对应关系。

在工程实现上，
将物体放置在`group`中，
就可以通过调整包装件的旋转和平移参数，
来实现物体绕任意轴的旋转效果。

【这是另一段棒到不行的视频】

本文的相关代码可见我的[代码笔记本](https://observablehq.com/@listenzcc/walking_leg "代码笔记本")。
