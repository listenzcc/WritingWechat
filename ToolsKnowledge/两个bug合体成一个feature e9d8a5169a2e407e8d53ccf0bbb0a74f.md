# 两个bug合体成一个feature

这个事情非常有趣。想象你是我，你改变了解码器的某个功能，但重启程序后发现这个新功能并没有实装。这时你开始怀疑一切，直到某个偶然的机会，你发现了一条看上去无关的进程占用了本应该释放的那个端口，你恍然大悟，原来解码服务一直驻留在系统中，已经守候了超过几个月的时间。

---
[toc]

## 这是个什么程序

这是一个多路数据实时汇总、呈现和机器学习处理的程序。它的特点是在显示端对实时性要求高，并且后端需要对流数据进行实时截取和分析。

我开始的想法是拆分两个线程（Thread），分别进行数据显示和机器学习处理。但这个思路很快就遇到了问题，因为数据的规模变大，而且包含了不同的模态。这就将两个线程扩展成了两组线程。

线程的性能嘛，懂得都懂。于是为了达到技术要求，我将它们归纳成了两个进程（Process），一个负责流信号截取，另一个负责机器学习算法推断。它们之间的桥梁是 websocket。为了尽可能地提高系统稳定性，我为推断进程搭建了websocket服务，它是一款异步服务，其异步特性用来避免上一个片段的推断工作耗时过长而导致系统拥堵。

![Untitled](%E4%B8%A4%E4%B8%AAbug%E5%90%88%E4%BD%93%E6%88%90%E4%B8%80%E4%B8%AAfeature%20e9d8a5169a2e407e8d53ccf0bbb0a74f/Untitled.png)

事情很完美，但我万万没想到，这是两个bugs齐心协力构成了一个出色的feature。

## 第一个bug

第一个bug出现在websocket的服务端。我拉起服务时的代码总结起来是这样的

```bash
# Standalone decoding server
python websocket_decoding_server.py &
# or, depending on python's interpolater
setsid python websocket_decoding_server.py

# Keep until cancle signal monitor program
python signal_monitor.py
```

有经验的开发者可以看到，如果用户多次执行拉起程序的话，它无疑会导致系统资源泄漏。因为我将解码服务器（websocket_decoding_server.py）的生存期与主程序解绑了：即使信号监视器被停止掉，解码服务器还会在系统中驻留。这是十分不好的事情。

## 第二个bug

我的第二个bug出现在解码服务器的开启阶段，它“野蛮地”或者说“固执地”使用同一个端口号

```python
async with websockets.serve(handler, "localhost", 8765) as server:
	# bala bala decoding things
	pass
```

这样做的缺点是如果系统中该端口号被占用，那么它将无法开启。我的错误主要集中在并没有为这个异常做处理，也就是说它既不会试图将错误raise出来，也不会尝试其他端口号。在我的程序中，它只会默默地把自己关掉。

## 无心插柳的feature

这两个bugs导致了一个无心插柳的feature。那就是，用户不必再单独拉起两个脚本，比如一个脚本拉起信号截取器，另一个脚本拉起解码服务器。相反，当第一次启动时，它们会自动启动。这时程序做了两件事情

1. 开启信号屏幕，它会不断截取流信号并获取解码结果；
2. 开启解码服务，负责根据信号片段算出解码结果。

当程序结束时，信号屏幕会被关闭，但意外的是，解码服务驻留在系统中，并且占据了相应的端口。

当程序再次启动时，两件事情有了变化

1. 开启信号屏幕，它会不断截取流信号并获取解码结果；
2. 解码服务开启失败，因为它的端口被前一个解码服务占用。

为什么说这是一个feature呢？因为它有两个好的方面

1. 它保证了复杂的解码模型只加载一次，变相提高了程序再次启动的速度；
2. 它始终占用目标端口，让这个端口始终用于自己的专有服务，避免其他服务挤占它。

那为什么说它还是一个bug呢？那就要回到程序的开发阶段。想象你是我，开发这个程序的程序员。你改变了解码器的某个功能，但重启程序后发现这个新功能并没有实装。这时你开始怀疑一切，直到某个偶然的机会，你发现了一条看上去无关的进程占用了本应该释放的那个端口，你恍然大悟，原来解码服务一直驻留在系统中，已经守候了超过几个月的时间。

这时我才发现，这是两个bugs通力协作产生了一个feature。