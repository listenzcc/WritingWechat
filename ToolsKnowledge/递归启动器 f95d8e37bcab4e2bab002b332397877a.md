# 递归启动器

递归的逻辑很简单，不是左脚踩右脚的虚无飘渺，而是不使用相同方法的不断挖掘。因此，只要规定了启动方向和边界条件，递归就能顺利进行。

[https://observablehq.com/@listenzcc/recursive-i](https://observablehq.com/@listenzcc/recursive-i)

---
- [递归启动器](#递归启动器)
  - [核心代码](#核心代码)
  - [功能拆解](#功能拆解)


## 核心代码

这是一段抄来的求解斐波那契数列第 n 项的递归代码，它分为三个部分，

1. 递归的启动器；
2. 递归的核心代码，即求斐波那契数列第 n 项的核心功能；
3. 输入参数 n=20。

```jsx
// Will output 6765

console.log(
	((c) => ((b) => b(b))((b) => c((a) => b(b)(a))))(
	  (f) => (n) => n <= 2 ? 1 : f(n - 1) + f(n - 2)
	)(20)
)
```

[会写递归超越了多少程序员? - 知乎](https://www.zhihu.com/question/589779747/answer/3025207105)

## 功能拆解

为了说明递归启动器的功能，我在代码中插了一个眼，看到了递归内部的树形结构

```jsx
res = {
  const arrayA = [];

  const res = ((c) =>
    ((b) => b(b))((d) =>
      c((a) => {
        arrayA.push({ a, d, "d(d)": d(d), c });
        return d(d)(a);
      })
    ))((f) => (n) => n <= 2 ? 1 : f(n - 1) + f(n - 2))(20);

  return { res, arrayA };
}
```

![Untitled](%E9%80%92%E5%BD%92%E5%90%AF%E5%8A%A8%E5%99%A8%20f95d8e37bcab4e2bab002b332397877a/Untitled.png)

为了简单起见，我尝试从白话的角度来角度它。

启动器是声明了一个虚函数 c （这种函数只有形式，但需要后续代码确定它到底实现什么功能），它的参数是一个函数，这个函数的参数是虚函数 b，功能是调用自身，即 b(b)。这是递归的基础。

后续的函数是以 d 为输入参数的函数，d 是以参数 a 执行函数 c。在函数 c 内部，d 与 d(d) 两个函数完成了从启动器外壳到递归内核的跨越，这是由于 d 被 d 调用时是执行了其中的 c 函数，而 c 又执行了 f 函数。

也因此，函数 f 就是将 f 绑定在 c 上。f 函数怎样定义递归，那么这个外壳就会怎样执行，它是一个合格的迭代器。