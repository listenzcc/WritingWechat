# 从 canvas 的角度理解图形程序

本文开始涉及具体问题，从 canvas 的角度理解如下三个问题

1. 高速准实时信号采集过程中（如 EEG 信号），如何完成信号的实时显示、处理和反馈？
2. 为什么“过高”的显示器刷新率可能导致系统准时性变差？
3. 在有图形的界面中，如何使“图形”与用户进行交互？

---
- [从 canvas 的角度理解图形程序](#从-canvas-的角度理解图形程序)
  - [采集和显示解耦合](#采集和显示解耦合)
  - [Canvas 工厂](#canvas-工厂)
  - [Canvas 的制造速度就是 FPS](#canvas-的制造速度就是-fps)


## 采集和显示解耦合

First thing first，我认为任何图形程序都应该将信号采集和显示过程解耦合。这样做的好处，或者更直接一些，这样做的必要性如下

1. 系统设计和部署阶段，允许显示设备与采集设备实现分布式部署；
2. 开发阶段，两种设备互相独立，易于独立开发；
3. 兼容性方面，除了屏幕显示设备之外，还可以支持直接存储在文件或内存中，不仅不受限于屏幕大小和分辨率等不可控因素，甚至可以使用位置随动的机械机构实现直接的模拟输出；
4. 稳定性方面，相互独立的采集和显示子系统易于实现独立日志、故障排查、平行备份等提升系统稳定性的设计理念。

以上这些说教式的好处可能不好理解，那我就换个方向，如果信号采集和信号显示没有解耦合，那么可能发生什么？

如果您使用过设计“不那么好”的显示程序或者玩过优化“不那么好”的图形 PC 游戏的话，那么您一定遇到过这种现象，那就是某次操作之后，界面好像被盖上一个白色蒙版一样，不再响应任何操作，只有“关闭”按钮被高亮出来，并且只有它能够被点击，只能用来关闭程序。

首先，这种现象并非程序的本意，而是操作系统检测到该程序“长时间”不响应“轮询”信号，从而判断程序卡死。操作系统为了避免其他正常运行的程序被这个卡死的程序耽误执行效率，因此提醒用户关掉它。那层白色的蒙板就是这种提醒。

从程序内部来看，造成这种现象的原因“通常”是程序在信号的采集端和处理端子系统消耗了过多的资源也没有完成计算任务，而可怕的是，显示端并没有与这些子系统“解耦合”，导致程序在试图刷新图形的时候，不知道自己下一帧需要呈现什么图形，程序因此而“卡死”。

## Canvas 工厂

回到 canvas 的图形设计思路，它是将全部视觉信息集中叠加到图片像素中，最终形成图片输出的设计思路。在解耦合的程序中，我们可以将信号的采集和计算过程理解成批量生产图片的过程。以最简单的信号流图为例，信号采集端不断采集并处理信号，我们把它的输出理解成一条河，川流不息。而显示端不断地对信号流的末端进行采样，这就像我们的 canvas 工厂不断地给这条河拍照，拍摄的照片就是这些信号的“图形化显示输出”。

![canvas-factory.png](%E4%BB%8E%20canvas%20%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F%20a10bf4214565478b998b2514805b93d8/canvas-factory.png)

## Canvas 的制造速度就是 FPS

不管信号本身的采集和处理速度是怎么样的，我们在采集端只有在自己准备好之后才完成信号之河的拍摄动作，并且将生成的 canvas 输出给显示终端。那么，显示端的两次拍摄之间的时间间隔就是图形界面的“刷新时间”。

实际上，如果我们讨论的是某个示波器或者游戏界面的话，这个时间间隔的倒数就是 FPS（每秒帧数），它代表显示端每秒刷新多少张图像，在典型应用中，FPS 是衡量图像或视频流每秒显示的帧数。在示波器、游戏界面或视频播放中，FPS 是一个重要的性能指标。较高的FPS意味着动画或视频看起来更加流畅，因为它们以更高的速度刷新。例如，如果一个游戏以 60 FPS 运行，这意味着游戏引擎每秒会将60帧画面渲染出来，然后显示在屏幕上。这会让游戏感觉非常平滑。

- 胶片电影的 FPS 一般是 24 帧；
- 液晶显示器的 FPS 能达到 60 ～ 360 帧；
- 电子游戏的 FPS 多多益善。

回到开篇提到的问题，为什么“过高”的显示器刷新率可能导致系统准时性变差？我想本文的内容给回答这个问题建立了讨论的基础，但全面的回答需要从好几个角度考虑，最重要的是如何在采集和显示解耦合的系统中保持信号的准时性。