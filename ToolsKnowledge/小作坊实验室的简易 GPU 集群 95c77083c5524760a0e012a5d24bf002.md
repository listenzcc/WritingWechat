# 小作坊实验室的简易 GPU 集群

这是一些我觉得使用计算机的研究生应该知道，但从日常交流看来，我又不知道大家知道不知道的事情。

---
- [小作坊实验室的简易 GPU 集群](#小作坊实验室的简易-gpu-集群)
- [背景篇](#背景篇)
  - [计算服务器与 PC 有何区别？](#计算服务器与-pc-有何区别)
  - [计算服务器集群的管理和调度](#计算服务器集群的管理和调度)
- [部署篇](#部署篇)
  - [小作坊式的科研工作需要怎样的计算服务器？](#小作坊式的科研工作需要怎样的计算服务器)
  - [直连带来的新问题](#直连带来的新问题)
  - [几种主流的 **File Sharing Solutions**](#几种主流的-file-sharing-solutions)
  - [实验室目前的集群管理方案](#实验室目前的集群管理方案)
    - [我们的数据是如何备份的？](#我们的数据是如何备份的)
    - [如何跨服务器、跨平台使用数据？](#如何跨服务器跨平台使用数据)
- [代码篇](#代码篇)
  - [CUDA, cuDNN 和 Pytorch](#cuda-cudnn-和-pytorch)
  - [我的 pytorch 为什么不好用？](#我的-pytorch-为什么不好用)
  - [如何通过最小的工作量让 pytorch-gpu 跑起来？](#如何通过最小的工作量让-pytorch-gpu-跑起来)
  - [Python 环境和使用建议](#python-环境和使用建议)
  - [针对 python 环境的几个典型问题](#针对-python-环境的几个典型问题)
  - [日常撰写代码的建议](#日常撰写代码的建议)
  - [日常撰写 word 文档的建议](#日常撰写-word-文档的建议)
  - [分享代码易出现的问题](#分享代码易出现的问题)
    - [最大的问题是代码的逻辑不清，功能重叠](#最大的问题是代码的逻辑不清功能重叠)
    - [其次是代码没有注释，比较认真的是用 argparse 当作注释](#其次是代码没有注释比较认真的是用-argparse-当作注释)


---

# 背景篇

## 计算服务器与 PC 有何区别？

1. **硬件配置**
    - 服务器通常拥有更强大的硬件配置，如更多的处理器核心、内存和存储容量，以应对大规模任务和高负载情况。
    - 个人电脑更侧重于用户体验，通常配置适用于日常办公和娱乐。
2. **用途**
    - 服务器用于提供服务、存储数据、运行应用程序等，以满足多用户、大规模任务的需求。
    - 个人电脑用于个人工作、学习、娱乐等，通常只服务于单一用户。
3. **稳定性与可靠性**
    - 服务器需要保证高可用性，通常采用冗余设备、备份策略等措施，以防止单点故障。
    - 个人电脑通常不需要如此高的可靠性。

二者的差别就像是重载卡车和家用轿车的区别，虽然都能在公路上跑，但设计和使用都有较大区别。除了噪声和体积大小之外，它们的使用方式也天差地别。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled.png)

![重载卡车通常需要更复杂的操作方式](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%201.png)

重载卡车通常需要更复杂的操作方式

## 计算服务器集群的管理和调度

典型的使用方式是采用**集群式管理和调度**，最有名的管理软件之一是 **[Sun Grid Engine](https://gridscheduler.sourceforge.net/htmlman/htmlman1/qsub.html?pathrev=V62u5_TAG)**

- Submit Host，用于提交作业到SGE集群的主机，通常也是管理节点。
- Administration Host，用于管理和配置SGE集群的主机，包括队列设置、用户权限等。
- Master Host，负责协调各个计算节点的任务分配和执行，是SGE的控制节点。
- Shadow Host，作为Master Host的备份，负责在Master Host发生故障时接管控制权。
- Execution Hosts，实际执行计算任务的主机，提供计算资源给作业运行。

**任务提交、调度与监控**

- 用户通过Submit Host提交作业到SGE集群。
- Administration Host配置作业队列、资源限制等信息。
- Master Host根据队列策略和资源可用性，将作业分配给Execution Hosts。
- 用户可以通过SGE的监控工具实时查看作业的状态和执行情况，包括等待、运行、完成等状态。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%202.png)

---

# 部署篇

## 小作坊式的科研工作需要怎样的计算服务器？

如果实验室采用集群式管理服务器，那么会对程序频繁微调的场景极不友好，因为

1. **任务调度延迟**：
    - 在集群中，任务的调度可能会受到其他任务的影响，导致任务开始执行的时间不稳定。这可能会使得频繁调整程序的工作变得不那么高效。
    
    解决方案（**将导致大家全部集中在 master 节点调程序，而真正有计算能力的 execution 节点无人问津**）：
    
    - 可以考虑在集群中设置一个专门用于测试和微调的节点，避免影响到其他正式任务的调度。
2. **资源竞争**：
    - 在集群中，多个任务可能会竞争有限的计算资源，导致资源分配不均匀。
    
    解决方案（**大家的科研任务都很“紧急”**）：
    
    - 可以通过合理配置任务队列、资源限制等，以及根据实验的优先级进行合理的资源分配。
3. **环境一致性**：
    - 在集群中，可能存在不同节点的环境配置不完全一致，导致在不同节点上运行程序时出现意外问题。
    
    解决方案（**科研用的程序版本管理极其混乱，同学自己都不确定要用哪些版本**）：
    
    - 可以通过容器化技术（如Docker）来保证程序在不同节点上的环境一致性。

> 最简单的解决方案是绕开 master host，采用直接连接的方式使用服务器。
> 

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%203.png)

## 直连带来的新问题

- 数据难以在多设备之间共享
- 单机的存储空间有限

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%204.png)

解决方案：用分布式系统的思路，构建统一的 File Share Solutions，通过 NFS 实现多机之间数据共享。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%205.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%206.png)

## 几种主流的 **File Sharing Solutions**

NFS（Network File System）是一种用于在网络上共享文件的协议和相应的实现。它允许不同操作系统的计算机通过网络访问和共享文件，使得文件可以在不同的设备之间进行共享和传输。

1. **分布式文件系统**：
    - NFS允许多台计算机在网络上共享文件和目录，使得这些文件和目录在不同设备上可以像本地文件一样被访问。
2. **基于客户端-服务器模型**：
    - NFS采用了客户端-服务器的架构，其中一个或多个计算机（客户端）请求访问文件，而另一台计算机（服务器）负责响应请求并提供文件访问服务。
3. **基于RPC协议**：
    - NFS使用了Remote Procedure Call（RPC）协议来实现客户端和服务器之间的通信。
4. **透明性**：
    - 对于用户和应用程序来说，NFS提供了一个透明的文件访问接口，使得远程文件的访问和本地文件的访问几乎没有区别。
5. **文件级别访问**：
    - NFS提供了对整个文件和目录的访问，而不是块级别的访问。这使得它适合于共享和访问大量小文件的场景。
6. **安全性和权限控制**：
    - NFS提供了基于用户和组的权限控制机制，可以限制用户对共享文件的访问。

Samba是一个开源的软件套件，用于实现Windows和Unix-like系统之间的文件和打印机共享。它允许Linux/Unix系统像Windows一样提供文件共享服务，并且能够与Windows网络环境无缝集成。

1. **文件共享**：
    - Samba允许Linux/Unix系统作为文件服务器，与Windows系统共享文件和目录，使得Windows用户可以访问和管理共享的文件。
2. **打印服务**：
    - Samba还支持将Unix打印机共享给Windows客户端，使得Windows用户可以直接打印到Unix/Linux系统上的打印机。
3. **透明性**：
    - 对于Windows用户来说，Samba提供了一个透明的文件访问接口，使得远程文件的访问和本地文件的访问几乎没有区别。
4. **支持多平台**：
    - Samba不仅可以在Linux/Unix系统上运行，也可以在其他操作系统上运行，如BSD、macOS等。

SSHFS（Secure Shell File System）是一个基于SSH协议的文件系统，可以通过SSH连接来实现远程文件的挂载和访问。它允许将远程主机上的文件系统挂载到本地主机上，使得用户可以像访问本地文件系统一样访问远程文件系统。

1. **安全性**：
    - SSHFS通过使用SSH协议来传输数据，实现了数据的加密传输，确保了传输过程的安全性。
2. **简单易用**：
    - 对于用户来说，SSHFS提供了一个简单的方式来挂载远程文件系统，无需复杂的配置和设置。
3. **透明性**：
    - 对于用户来说，通过SSHFS挂载的远程文件系统在操作上与本地文件系统几乎没有区别，可以像访问本地文件一样进行操作。
4. **不需要额外的服务端软件**：
    - 与其他远程文件系统不同，SSHFS不需要在远程主机上安装额外的服务端软件，只需要确保SSH服务正常运行即可。
5. **支持多平台**：
    - SSHFS可以在多个操作系统上使用，包括Linux、macOS和Windows（通过相应的SSHFS客户端工具）。

## 实验室目前的集群管理方案

经过综合考虑，实验室目前采用 NFS 方案进行文件共享，并且有专门的工具监控服务器的运行状态。现在这些数据是用 MongoDB 在维护，目前已经累积了 50 万条。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%207.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%208.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%209.png)

### 我们的数据是如何备份的？

实验室的重要数据资源在 NAS 集群中存储，并且我们还有大量的存储空间可用。每个服务器都有一个目录 /nfs/datastation，这个目录对应一台 NAS 的共享目录，该目录内的全部文件对所有服务器和所有人可见。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2010.png)

![剩余 30T 存储空间](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2011.png)

剩余 30T 存储空间

![剩余 30T 存储空间](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2012.png)

剩余 30T 存储空间

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2013.png)

### 如何跨服务器、跨平台使用数据？

Q：如果我要使用 NAS 里面的数据，我需要将它们“复制”到我的目录下吗？

A：不需要，甚至不允许这样做，因为这会造成资源浪费。需要“复用”的数据只应该存在一份（不考虑异地灾备）。

Q：那我应该怎么做？

A：使用“符号链接”，将你感兴趣的数据链接过来。

Q：这样做的好处是什么？

A：节省硬盘空间，并且能保证你用的数据和别人用的数据是“一份数据”，你甚至能用它共享自己的开发环境。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2014.png)

Q：我要怎么做？

A：`ln -s` 命令创建的是符号链接，也称为软链接。软链接是一种特殊类型的文件，它包含了指向另一个文件或目录的路径。与硬链接不同，软链接只是一个指向实际文件或目录的路径，而不是实际的数据块或节点。因此，软链接允许在文件系统中引用其他文件或目录，类似于一个快捷方式。比如，假设你有一个文件 `file.txt`，你可以使用以下命令创建一个指向它的软链接：

```bash
ln -s /path/to/file.txt symlink.txt
```

这样，`symlink.txt` 就成为了一个指向 `/path/to/file.txt` 的软链接。

软链接的优点包括：

1. **灵活性**：可以随时更改软链接的目标，而不需要创建一个新的链接。
2. **跨文件系统**：可以在不同的文件系统之间创建软链接，而硬链接只能在同一个文件系统内创建。
3. **允许链接目录**：可以创建指向目录的软链接。

因此，软链接更类似于一个指针，指向了实际的文件或目录，而不是对实际文件或目录的拷贝。

Q：如何控制数据权限？

A：在 Linux 文件系统中，权限由三组字符表示，分别代表文件所有者、文件所属组和其他用户的权限。每组权限包括读取（r）、写入（w）和执行（x）。数字权限模式（如 777）是一种用数字表示文件或目录权限的方法：

- 第一个数字表示所有者的权限。
- 第二个数字表示文件所属组的权限。
- 第三个数字表示其他用户的权限。

每个数字可以是 0、1、2、4或者它们的组合，分别对应不同的权限：

- 0：无权限
- 1：执行权限
- 2：写入权限
- 4：读取权限

要将数字权限模式解释为具体的权限组合，可以将它们分解成三个数字，例如 777：

- 第一个数字（7）表示所有者拥有读取、写入和执行权限（4 + 2 + 1）。
- 第二个数字（7）表示文件所属组也拥有读取、写入和执行权限。
- 第三个数字（7）表示其他用户也拥有读取、写入和执行权限。

这样的权限模式（777）将文件或目录对所有用户都开放，允许任何用户读取、写入和执行它。

---

# 代码篇

## CUDA, cuDNN 和 Pytorch

CUDA、cuDNN 和 PyTorch 是在深度学习领域中常用的三个重要工具/库，它们之间有以下关系：

1. **CUDA**（Compute Unified Device Architecture）：
    - CUDA 是由 NVIDIA 提供的并行计算平台和编程模型。它允许开发者利用 NVIDIA GPU 的并行计算能力来加速计算密集型任务，特别是在科学计算和深度学习等领域。
2. **cuDNN**（CUDA Deep Neural Network）：
    - cuDNN 是 NVIDIA 提供的深度神经网络库，它是针对深度学习任务进行了优化的 CUDA 库。cuDNN 提供了高效的卷积、池化、归一化等操作的实现，可以显著加速深度学习模型的训练和推断过程。
3. **PyTorch**：
    - PyTorch 是一个开源的深度学习框架，由 Facebook 提供。它提供了一个灵活而强大的接口，可以用于构建、训练和部署深度学习模型。PyTorch 具有动态计算图的特点，使得模型的构建和调试更为灵活和直观。

关系：

- CUDA 提供了对 NVIDIA GPU 的并行计算能力的底层支持，使得开发者可以利用 GPU 的并行计算能力来加速各种计算密集型任务，包括深度学习任务。
- cuDNN 则是针对深度学习任务提供了优化的 CUDA 库，提供了一系列高效的深度学习操作的实现，如卷积、池化等。cuDNN 的存在使得深度学习框架能够充分利用 GPU 的性能。
- PyTorch 是一个深度学习框架，它可以利用 CUDA 和 cuDNN 提供的能力来进行高效的模型训练和推断。PyTorch 提供了对 CUDA 和 cuDNN 的高级封装，使得开发者可以方便地在 PyTorch 中使用 GPU 加速。

总的来说，CUDA 提供了底层的并行计算能力，cuDNN 为深度学习任务提供了高效的实现，而 PyTorch 则是一个在 CUDA 和 cuDNN 基础上构建的灵活深度学习框架。开发者可以在 PyTorch 中方便地利用 CUDA 和 cuDNN 加速模型的训练和推断。

## 我的 pytorch 为什么不好用？

我见过无数个人问我这个问题，“我的 pytorch 为什么不好用？”。这其实不怪同学有疑问，因为中文互联网全部的材料都以讹传讹地告诉你：想装 pytorch 要先买显卡，再装驱动，再装 cuda, cudnn ……。怎么验证装好了呢？需要你看看 nvcc 的版本号。当然，这些教程还需要你确保 cuda 和 cndnn 与要安装的 pytorch 是兼容的。

接下来就是见证奇迹的时刻，我能找到无数台机器，它没有装 nvcc，但 pytorch 的 cuda 好用；我还能找到无数台机器，它的 nvcc 装得异常完美，但 pytorch 不支持 cuda。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2015.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2016.png)

## 如何通过最小的工作量让 pytorch-gpu 跑起来？

出现以上问题的原因是 python 有自己的运行时环境（runtime），你只需要确保显卡的驱动版本不过于落后，就可以用 pip 或者 conda 安装一个叫做 pytorch 的东西，安装方式如下

```bash
conda install pytorch==1.x.x torchvision cudatoolkit=xx.x
# or pip install pytorch==1.x.x torchvision cudatoolkit=xx.x
```

事实上，python 在能够通过 cudatoolkit 包安装自己的 cuda 和 cudnn 支持包，你甚至都不需要自己考虑版本问题。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2017.png)

## Python 环境和使用建议

Python 的运行环境（runtime）可以理解为 Python 解释器的工作环境，它包括了 Python 解释器本身以及与之相关的一些库和配置。虚拟环境（Virtual Environment）是一种将特定项目与系统中其他项目隔离开来的方式。它允许你在同一台计算机上同时运行多个项目，每个项目都可以有自己独立的依赖库和配置，互相之间不会产生冲突。虚拟环境使得你可以为每个项目选择特定版本的Python解释器以及相关的库，而不会影响全局的Python环境。这对于管理不同项目的依赖关系和版本非常有用，可以保证项目之间的独立性和稳定性。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2018.png)

**在 VS Code 中自动管理 venv：**

1. **Python 扩展**：
    - 在 VS Code 中，你可以安装 Python 扩展，它提供了许多与 Python 开发相关的功能，包括虚拟环境的管理。
2. **创建虚拟环境**：
    - 打开你的项目文件夹后，VS Code 会检测到你的项目中是否存在虚拟环境，如果不存在，它会提示你创建一个新的虚拟环境。
3. **选择解释器**：
    - 在 VS Code 的底部状态栏中，你可以看到当前使用的 Python 解释器。点击它，可以选择已存在的虚拟环境或创建一个新的。
4. **自动激活**：
    - 一旦你选择了虚拟环境，VS Code 会自动激活该环境，并在终端中显示相应的提示符。

**在 PyCharm 中自动管理 venv：**

1. **创建项目时选择虚拟环境**：
    - 在创建新项目时，PyCharm 会询问你是否要创建一个虚拟环境。你可以选择在项目文件夹中创建一个新的虚拟环境，或者选择已存在的虚拟环境。
2. **切换虚拟环境**：
    - 在 PyCharm 的右下角，你可以看到当前使用的 Python 解释器。点击它，可以选择已存在的虚拟环境或创建一个新的。
3. **自动激活**：
    - 一旦你选择了虚拟环境，PyCharm 会自动激活该环境，并在终端中显示相应的提示符。

## 针对 python 环境的几个典型问题

- 我的 pip 为什么不好用？
- 为什么我的 module 版本不对？
- 我如何知道这个程序能不能用？

这些问题都能够通过 shell （bash, zsh, powershell, ……）操作解决

1. 首先，linux 寻找可执行文件的机制是“先到先得”，在 Linux 中，当你输入一个命令时，系统会按照一定的顺序搜索可执行文件的路径。这个搜索顺序是从系统环境变量 **`PATH`** 中定义的路径列表中查找，按照列表顺序逐个查找，找到第一个匹配的可执行文件就会执行它。如果你的 pip 不好用，那么可能是由于系统找错了目录。这个排查方法适用于 linux 的许多问题场景。
2. 针对 pip 命令，你需要根据 **`environment.xml`** 文件中列出的依赖项来安装所需的库。如果你做虚拟环境时指定了 pip 的位置，那么它就会出现在 conda 指定的环境变量里。 如果没指定的话，那么这个就看你原来的系统指定的 pip 是哪个。
3. 其次，如果有程序报错，可以通过 ldd 等命令查看它需要的 so 库。**`ldd`** 是一个用于检查可执行文件或共享库文件依赖关系的命令。它会列出一个程序或库文件所依赖的动态链接库（.so 文件）的绝对路径，以及它们是否能够找到。当一个程序在运行时报错，特别是与动态链接库相关的错误时，可以使用 **`ldd`** 命令来查看程序依赖的库是否存在或者路径是否正确。

![指定 pip 的配置](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/d3c231d53024fd638a60a8381a60298.png)

指定 pip 的配置

![未指定 pip 的配置](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/8e794e0e9853ae8cf45154e4893afe0.png)

未指定 pip 的配置

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2019.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2020.png)

## 日常撰写代码的建议

写代码要考虑的问题

- 如何让别人快速上手我的代码？
- 如何实现代码版本控制？
- 什么是接口？如何合作写程序？
- 什么是测试？如何确保程序不会崩溃？

这些问题没有固定的解决方案，但要养成好的编程习惯。养成编程习惯是有捷径的，除了多读代码之外，还可以使用 AI 工具，我现在比较喜欢的是 Sourcery，它可以自动生成注释、代码解释、修改建议甚至是测试用例。

> 我用它排查 bug 的案例，它找到了“随机矩阵”不能有 0 值，否则可能导致定义不符合的 bug。这种 bug 非常隐蔽且非常恶性，因为它出现的概率非常低，可一旦出现就会导致系统不稳定。
> 
> 
> Unusual Things
> The np.random.rand call generates values in the range [0, 1), but stochastic matrices require non-negative values. This could lead to unexpected behavior if a matrix with negative values is passed to compute_eig.
> 

Sourcery 评价函数的三个方面，得分高的代码具有复杂性低、简短和记忆负荷小等特点

1. 复杂性 (Complexity)：**复杂性越低代表函数功能越单一，这是好事情，说明函数功能的内聚性高。**
    - Sourcery 会分析代码的复杂性，主要是指代码的结构、逻辑和组织方式是否简洁和清晰。
    - 评价代码是否存在过多的嵌套、长方法、复杂的控制流程等，这些因素可能会增加代码的阅读难度和维护成本。
    - 高复杂性的代码可能会降低代码的可读性和可维护性。
2. 大小 (Size)：**在完成功能的前提条件下，代码规模越小越好。**
    - 这里指的是代码的规模，可以通过代码行数、函数数量等来衡量。
    - Sourcery 会考虑代码的大小是否适中，避免过于臃肿或者过于简单，以及是否符合良好的代码组织原则。
3. 工作记忆 (Working Memory)：**好的代码应该让人能看懂，才有改进和复用的余地。**
    - 这指的是阅读和理解代码所需的认知负担。
    - Sourcery 会评估代码是否容易阅读和理解，是否符合常见的编程惯例，以减少开发者在阅读代码时的认知负担。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2021.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2022.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2023.png)

[Sourcery Features - Sourcery Documentation](https://docs.sourcery.ai/What-Is-Sourcery/Features/)

## 日常撰写 word 文档的建议

- 如何分享带公式的文档？
- 如何传递图和表的 legends？
- 什么是域和引用？

Word 是排版工具，因此在共享 word 文档时，需要将排版搞搞好，排版包括自动编号、自动图例、自动目录等。排版良好的 word 文档，无论粘贴到哪里，都不会给汇总人带来太大的负担，但排版不佳的文档，对于汇总人来说，那就是不折不扣的灾难。

Microsoft Word 提供了丰富的排版工具，其中域（field）工具是一个强大的功能，可以用于自动化文档的编号、图例、目录等。

1. **自动编号**：
    - 使用域工具可以实现自动编号，比如对章节、标题、图表等进行编号。通过将编号字段嵌入文档中，可以确保编号会随着文档内容的变化而自动更新。
2. **自动图例**：
    - 对于图表、表格等，可以使用域工具来创建自动图例。这样在文档中插入新的图表时，图例会自动更新，无需手动调整。
3. **自动目录**：
    - Word 中的目录域可以根据文档的章节标题自动生成目录。这样在文档结构变化时，只需刷新目录域即可更新目录内容。
4. **交叉引用**：
    - 域工具还可以用于创建交叉引用，比如引用文档中的章节、图表、表格等。这可以确保引用始终指向正确的位置。

以下是包含域代码的公式和图例的 word 文档样例，在进入第2章后，公式的编号自动改变了。对于这样的文档，即使后续增加章节，序号也不会乱掉。

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2024.png)

![Untitled](%E5%B0%8F%E4%BD%9C%E5%9D%8A%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AE%80%E6%98%93%20GPU%20%E9%9B%86%E7%BE%A4%2095c77083c5524760a0e012a5d24bf002/Untitled%2025.png)

## 分享代码易出现的问题

### 最大的问题是代码的逻辑不清，功能重叠

耦合和解耦是软件开发中非常重要的概念，它们直接影响到程序的可维护性和可重用性。

- **耦合**是指模块或组件之间的依赖关系程度。当模块之间高度依赖时，称之为紧耦合；反之，如果模块之间依赖较少，称之为松耦合。
- **解耦**是指降低模块之间的依赖关系，使得模块可以独立存在或者被替换。解耦的目的是提高代码的灵活性和复用性。

但很多代码是使用一个 **main** 函数跑到底的形式，从数据获取开始到解码模型分类结束，全部功能都杂糅在一块，导致输入信号有一丁点变化都会使代码失效。

### 其次是代码没有注释，比较认真的是用 argparse 当作注释

`doc comments` 和 `argparse` 是两种在 Python 编程中用于文档和参数处理的不同工具。`doc comments` 用于在代码中提供详细的文档，方便其他开发者理解和使用代码；而 `argparse` 用于处理命令行参数，使得脚本可以接受不同的输入并作出相应的处理。它们在不同层次上提供了文档和参数处理的功能。

1. **Doc Comments**：
    - `doc comments` 是在代码中嵌入的注释，用于解释代码的功能、用法以及实现细节等信息。它们通常以多行字符串的形式出现，可以包含在函数、类、模块等定义的顶部。
    - `doc comments` 通常使用三引号（`"""`）来界定，允许开发者编写详细的文档，包括函数、类、模块的说明，以及参数、返回值、使用示例等信息。
    - 例子：
        
        ```python
        def my_function(arg1, arg2):
            """
            This is a doc comment.
        
            Args:
                arg1: Description of arg1.
                arg2: Description of arg2.
        
            Returns:
                Description of the return value.
            """
            # Function implementation...
        
        ```
        
    - `doc comments` 对于代码的可读性和可维护性非常重要，它们可以帮助其他开发者理解代码的作用和用法，也可以用于自动生成文档。
2. **argparse**：
    - `argparse` 是 Python 的一个标准库，用于解析命令行参数。它允许你在运行 Python 脚本时从命令行传递参数，并可以方便地处理这些参数。
    - 通过使用 `argparse`，你可以定义脚本所需的参数、选项等，然后从命令行中读取这些值，以便在脚本中使用。
    - 例子：
        
        ```python
        import argparse
        
        parser = argparse.ArgumentParser(description='Description of the script')
        parser.add_argument('input_file', help='Input file path')
        parser.add_argument('--output', '-o', help='Output file path')
        
        args = parser.parse_args()
        
        ```
        
    - 在上面的例子中，`argparse` 被用来解析命令行参数，并提供了一个帮助文本（description）来描述脚本的作用。同时，定义了一个必需的参数 `input_file` 和一个可选的参数 `output`。