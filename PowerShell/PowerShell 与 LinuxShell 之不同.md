## PowerShell 与 LinuxShell 之不同

[PowerShell](https://www.powershellgallery.com/ "PowerShell") 是微软自带的交互软件，与类 Linux 系统的 Shell 具有一定的平行替代关系。
但使用起来，二者却给人以完全不同的感觉。

当然，PowerShell （PS）令人智熄的蓝色界面有一定影响，这却不是主要原因。
其根源在于 Windows 系统（W）与类 Linux 系统（L）的不同构建哲学。
一句话来说，L 是以文件为基础而构建的系统，W 是以抽象为基础而构建的系统。
在 L 系统中，用户所看见和所操作的都是具体的文件，所谓“一切皆文件”；
而在 W 系统中，用户始终处于抽象构建的类结构中，所见的都是一望无际的抽象概念。
孰优孰劣我们不去评价，具体和抽象的区别却是在实际使用中产生直观的感受。

---

## 先务虚

举个栗子：

1. 在 L 系统中，几乎所有的命令都将终端当作一张白纸在用，比如常用命令 `ls` 是将当前目录下的文件以各种各样的方式“打印”到屏幕上，一般来说，每个文件或目录对应单独的一行输出，根据命令参数的不同，可以包括名称、创建时间、权限等一系列信息；
2. 而在 W 系统中，如果你使用的是 PS，那么你能发现一个神奇的现象，就是你可以找一个变量来接收 `ls` 的输出结果，并且这个变量是一个类似列表的玩意儿，你甚至可以单独操作其中的某个“元素”，同时，不难发现，这些“元素”对应着当前目录下的文件或目录，或者更正经一点的说法，把“目录”看是“树”，这些“元素”就是“树叉”或“叶子”，分别代表“子目录”和“文件”；
3. 这些“元素”具有各自的“属性”，包括名称、创建时间、权限等一系列信息。

有点计算机科学基础的同学不难理解，在 PS 的环境下，一切都可以说是类似计算机语言中“类”或“结构”的东西，换句话说，一切都是操作对象的抽象。

再举一个栗子：

1. 在 L 系统中，键盘、鼠标、硬盘等所有计算机能够操作的外设都是文件，只不过这些文件是动态变化的，比如 `/dev/input/mouse0` 代表鼠标， `/dev/sda#` 代表硬盘等等，系统通过检测这些动态变化的文件来响应它们产生的事件、或对它们进行操作；
2. 而在 W 系统中，同样这些设备的存在就变成了抽象的设备类和它们的接口，就是你能从“设备管理器”里看到的东西。

从这个角度来看，我个人更喜欢 L 系统，因为它更加看得见摸得着；但对于 W 系统只有膜拜，因为它更加贴近于一个理想中的抽象的计算机世界；如果有“MATRIX”那样的世界，我相它更加可能是 W 那样的；如果我要自己实现一个小功能的小系统，我会采用 L 的理念，因为它可控，而且看上去比较优雅。

## 再务实

### 先说 L 系统

在 L 系统中鼎鼎大名的三剑客 `Grep、Sed、Awk` 都是文本处理的高手，一个是高效的单行文本探索器、一个是高效的单行文本编辑器、一个是面向单行文本的编程语言。
它们在 L 系统中横行天下的原因是 L 系统是基于文件的操作系统，在系统设计过程中，高效的单行文本传递几乎是系统的命脉。
而它们显然的短板自然地是面向多行文本时的无力感，将这三个神器使用得炉火纯青的大神与小白之间的区别正是在面对多行文本处理的情况时，所使用的奇技淫巧，我非常尊重前辈在这方面所作的努力，但这些工作并不是开拓性和创新性的工作，而是带着镣铐跳舞的无奈之举。

举个栗子：

- 在 L 系统中，我们有时会关心设备的情况，要用到 `lspci` 这个命令，列出系统 PCI 总线上挂载的东东;
- 由于输出太长，我们使用 `lspci |grep -e [PAT]` 来找到由 "PAT" 字符串所指定的内容，事情往往没完，当我们想看上下文时，需要加上 `-C#` 参数，其中的 `#` 代表要看上下文的几行;
- 剩下的事情基本就听天由命了，因为要找的东西不见得就一定在指定的范围内，范围太小会丢东西，太大又没意义，况且你也不能让后面接收这个信息的程序自动判断哪些是有用的信息;
- 这就是 L 系统的短板。

### 再说 W 系统

在习惯了 L 系统的文件操作之后，在 W 系统中的 PS 一开始看上去就是一场彻头彻尾的灾难。因为它看上去太“反 人 类”了；
所有显示在 PS 里的东西都成了抽象的“类”，我们习惯的文件消失了。

举个栗子：

- 当你在上网，看到一张图，有了它的 URL 就可以用 `wget` 命令下载下来，在 L 系统中，它会乖乖地以文件的形式出现在的目录下；
- 而在 PS 环境下，它弄出来一个叫 `Invoke-WebRequest` 的替代，它的 alias 名称正是 wget，你用同样的命令试图下载，它会给你返回一个类，这个类基本上长这样

<p style="text-align: center;">在 PS 中的一个标准的网络请求响应</p>

```
StatusCode        : 200
StatusDescription : OK
Content           : {255, 216, 255, 224...}
RawContent        : HTTP/1.1 200 OK
                    X-Timestamp: 1458043266.82517
                    Age: 42
                    X-Cache: cp4021 miss, cp4024 hit/2
                    X-Cache-Status: hit-front
                    Server-Timing: cache;desc="hit-front", host;desc="cp4024"
                    Strict-Transport-Secu...
Headers           : {[X-Timestamp, 1458043266.82517], [Age, 42], [X-Cache, cp4021 miss, cp4024 hit/2], [X-Cache-Status,
                     hit-front]...}
RawContentLength  : 98440
```

如果你下载的是一张图，恭喜你，你的图现在是躺在`Content`成员里的一列数，它的长度大概是`98K`，标记在了`RawContentLength`里，你还能看到网络连接时的全部信息，存在`Headers`里。
也就是说，你的图，现在是一个抽象“类”，你除了看不见它，它的全部信息都对你的透明的，是不是很开心？
而如果你想看图，你需要在执行 `Invoke-WebRequest` 时带上 `-OutFile` 参数，那么你的图才会出现在那里。

当然，你的图并没有消失，它只在以编码数字的形式静静地躺在“Content”字段里，你可以把它存储在一个文件里，然后用“Python”或其他软件对它进行解析

<p style="text-align: center;">使用 Python 解析 Content 的例子</p>

```python
from io import BytesIO
from PIL import Image
raw = open(fname, 'rb').read()
numbers = np.array([int(e) for e in raw.decode('utf-16').split()])
parsedBytes = ''.join([chr(e) for e in numbers]).encode('latin1')
img1 = BytesIO(parsedBytes)
Image.open(img1)
```

到此为止，我们已经论述了 L 和 W 两者的不同，下面的文章将着重对 PS 的功能进行学习和探索。

为什么是 PS ？
我们可以从后一个例子来看，它其实是比 L 系统更进一步地把计算机系统里的五脏六腑都以抽象“类”的良好包装形式呈现给用户，用户才能看到这些信息，了解以前自以为了解的，然而并没有真正了解的东西。
