# 继续SDF：简单压倒一切

本文尝试一种计算简单，且适用于任意凸多边形SDF计算的快速算法。在这个算法中，对于每条边只需要计算二次内积即可，因此这是一种复杂度为$N$的算法。

[Easy to compute the SDF of triangle](https://observablehq.com/@listenzcc/easy-to-compute-the-sdf-of-triangle)

---
- [继续SDF：简单压倒一切](#继续sdf简单压倒一切)
  - [任意凸多边形的SDF](#任意凸多边形的sdf)
  - [快速算法](#快速算法)
    - [第一次内积](#第一次内积)
    - [第二次内积](#第二次内积)
    - [处理内部点](#处理内部点)
  - [非凸多边形失效的图示](#非凸多边形失效的图示)


## 任意凸多边形的SDF

什么是多边形？多边形就是**由若干条线段组成的封闭平面图形**。什么是凸多边形？凸多边形是多边形的子集，就是**所有内角都小于180度的多边形**。在凸多边形中，任意两点连线上的点都在该多边形内部。凸性质意味着多边形没有凹陷的部分，从而确保连接多边形内部任意两点的线段完全位于多边形内。

$$
\left.\begin{matrix}
p_1 &\in \mathbb{P} \\
p_2 &\in \mathbb{P} \\
\end{matrix}\right\} \Rightarrow
\begin{cases}
\begin{gather*}
a p_1 + b p_2 &\in \mathbb{P}\\
a + b &= 1\\
a, b &\in (0, 1)
\end{gather*}
\end{cases}

$$

下图是随机生成的多边形的实时演算SDF图样，符号为正代表点在多边形外部；符号为负，代表它在多边形内部。

![20240112-204836.gif](%E7%BB%A7%E7%BB%ADSDF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8E%8B%E5%80%92%E4%B8%80%E5%88%87%208c75300d88bc4b279dce48cf216b0f57/20240112-204836.gif)

![Untitled](%E7%BB%A7%E7%BB%ADSDF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8E%8B%E5%80%92%E4%B8%80%E5%88%87%208c75300d88bc4b279dce48cf216b0f57/Untitled.png)

## 快速算法

本算法需要针对每条边的线段进行计算，如下样例所示，以点$E$为原点，首先计算任意点$G$与多边形重心$I$的位置关系

$$
I = \frac{1}{n}\sum_{i=1}^{n} p
$$

其中，$n$代表多边形的边数。由之前分析可知，$I$点必在多边形内部。

### 第一次内积

考虑向量$\vec{ED} = \begin{bmatrix}x, y\end{bmatrix}^T$，按直线方程分别计算$I$与$G$与直线的位置关系，若二者异号，代表我们需要对它进行进一步分析，即

$$
(x_Iy - y_Ix)(x_Gy-y_Gx) < 0
$$

上式代表$I$和$G$两个点分别处于直线$ED$两侧。显然，如果对于每条边都进行上述分析，若点$G$始终与$I$处于同侧，则它必然在多边形内部。而在计算SDF时，我们一般只对多边形之外的点更感兴趣。因此无须处理这些点。

### 第二次内积

接下来，若满足上述不等式条件，则计算向量$\vec{EG}$与$\vec{ED}$的内积。

$$
v_1\cdot v_2 = x_1 x_2 + y_1y_2
$$

单就这条边$ED$来说，点$G$可能处于$3$个区域

- 红区：此时最近点为$E$；
- 绿区：此时最近点在$ED$上；
- 蓝区：此时最近点为$D$。

$$
\begin{cases}
red:& dot <0\\
blue:& dot > \Vert ED \Vert\\
green: & others
\end{cases}
$$

当处于绿区时，最近点可以通过下式计算

$$
p_{nearest} = E + \vec{ED} * r \quad, r = \frac{dot}{\Vert ED \Vert}
$$

最后，为了避免出现找到的最近距离不是全局最优的情况，需要对每条边进行遍历，选择距离最近点，该点的距离就是SDF的值。该值的符号为正代表点在多边形外部。

### 处理内部点

接下来，由于多边形内部的点必然是全部与$I$同侧的点的集合，因此对于这些点，只需要用“第二次内积”算法处理它即可，因为这些点必然处于绿区。只不过符号为负，代表它在多边形内部。综上所述，在这个算法中，对于每条边只需要计算二次内积即可，因此这是一种复杂度为$\mathcal{O}=N$的算法。

![Untitled](%E7%BB%A7%E7%BB%ADSDF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8E%8B%E5%80%92%E4%B8%80%E5%88%87%208c75300d88bc4b279dce48cf216b0f57/Untitled%201.png)

## 非凸多边形失效的图示

对于非凸多边形，上述算法将失效，如下图所示。左图中不再能够保证红区内的点都在多边形外，右图更过分，它甚至不能保证重心在多边形内。

![Untitled](%E7%BB%A7%E7%BB%ADSDF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8E%8B%E5%80%92%E4%B8%80%E5%88%87%208c75300d88bc4b279dce48cf216b0f57/Untitled%202.png)

![Untitled](%E7%BB%A7%E7%BB%ADSDF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8E%8B%E5%80%92%E4%B8%80%E5%88%87%208c75300d88bc4b279dce48cf216b0f57/Untitled%203.png)